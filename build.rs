use std::collections::BTreeSet;
use std::path::{Path, PathBuf};

// #weloveduplicatingcode
pub trait ExpectError<T> {
	fn expect_error(
		self,
		msg: &str,
	) -> T;
}

impl<T, E: std::fmt::Debug> ExpectError<T> for Result<T, E> {
	fn expect_error(
		self,
		msg: &str,
	) -> T {
		self.expect(&format!("\x1b[31;1m[ERROR] {}\x1b[0m", msg))
	}
}

fn process_dir(
	dir_path: &Path,
	base_path: &Path,
	module_entries: &mut BTreeSet<String>,
	dir_modules: &mut BTreeSet<String>,
	function_entries: &mut Vec<String>,
) {
	for entry in std::fs::read_dir(dir_path)
		.expect_error(&format!("Failed to read {:?} directory", dir_path))
	{
		if let Ok(entry) = entry {
			let path = entry.path();

			if path.is_dir() {
				if let Some(dir_name) = path.file_name().and_then(|s| s.to_str()) {
					dir_modules.insert(format!("pub mod {};", dir_name));

					process_dir(
						&path,
						base_path,
						module_entries,
						dir_modules,
						function_entries,
					);
				}
			} else if path.is_file() {
				if path.extension().map_or(false, |ext| ext == "rs") {
					if let Some(filename) = path.file_stem().and_then(|s| s.to_str()) {
						if filename == "mod" {
							continue;
						}

						let parent_dir = path
							.parent()
							.and_then(|p| p.file_name())
							.and_then(|s| s.to_str());
						let is_in_subdir = parent_dir.map_or(false, |dir| dir != "commands");

						if filename.ends_with("_command") {
							if is_in_subdir {
								module_entries.insert(format!("pub mod {};", filename));
							} else {
								dir_modules.insert(format!("mod {};", filename));
							}

							if let Some(command_name) = filename.strip_suffix("_command") {
								let function_path = if is_in_subdir {
									format!(
										"\n\t\t{}::{}::{}",
										parent_dir.unwrap(),
										filename,
										command_name
									)
								} else {
									format!("\n\t\t{}::{}", filename, command_name)
								};
								function_entries.push(format!("{}()", function_path));
							}
						} else {
							if is_in_subdir {
								module_entries.insert(format!("pub mod {};", filename));
							} else {
								dir_modules.insert(format!("pub mod {};", filename));
							}
						}
					}
				}
			}
		}
	}
}

fn main() {
	let base_path = PathBuf::from("src/commands");
	let mut module_entries: BTreeSet<String> = BTreeSet::new();
	let mut dir_modules: BTreeSet<String> = BTreeSet::new();
	let mut function_entries = vec![];

	process_dir(
		&base_path,
		&base_path,
		&mut module_entries,
		&mut dir_modules,
		&mut function_entries,
	);

	let mut root_modules: Vec<_> = dir_modules.into_iter().collect();
	root_modules.sort();
	let mod_content = format!(
		"#![cfg_attr(rustfmt, rustfmt_skip)]\n// This file is autogenerated by build.rs, do not edit.\n\n{}\n\npub fn get_all_commands() -> Vec<poise::Command<crate::Data, crate::types::Error>> {{\n    vec![{}]\n}}",
		root_modules.join("\n"),
		function_entries.join(", "),
	);

	std::fs::write("src/commands/mod.rs", mod_content).expect_error("Failed to write to mod.rs");

	for entry in
		std::fs::read_dir(&base_path).expect_error("Failed to read src/commands/ directory")
	{
		if let Ok(entry) = entry {
			let path = entry.path();
			if path.is_dir() {
				let modules: Vec<_> = module_entries.iter().map(|s| s.as_str()).collect();
				let mod_content = format!(
					"#![cfg_attr(rustfmt, rustfmt_skip)]\n// This file is autogenerated by build.rs, do not edit.\n\n{}",
					modules.join("\n")
				);
				let mod_path = path.join("mod.rs");
				std::fs::write(mod_path, mod_content)
					.expect_error("Failed to write subdirectory mod.rs");
			}
		}
	}
}
